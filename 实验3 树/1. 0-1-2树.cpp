#include<bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin >> t;  // 读取测试案例数

	// 遍历每一个测试案例
	while (t--) {
		int a, b, c;
		cin >> a >> b >> c;  // 读取每个测试案例中的 a, b, c

		// 检查二叉树的性质是否成立：如果 a + 1 != c，则说明无法形成有效的二叉树
		if (a + 1 != c) {
			cout << -1 << '\n';  // 不满足条件，输出-1
		}
		// 特殊情况，当 a 为 0 时，树的高度就等于 b，因为所有节点都是叶节点
		else if (a == 0) {
			cout << b << '\n';  // 输出高度 b
		} else {
			// 计算完全二叉树的高度：log2(a) 获取完全二叉树的深度
			int k = log2(a);

			// 计算最底层空余的节点数量，空余节点是因为最后一层并不完全填满
			int x = (1 << (k + 1)) - a - 1;

			// 如果 b 节点数不足以填满最后一层，则树的高度就是完全二叉树的高度
			if (b <= x) {
				cout << k + 1 << '\n';  // 高度为 k+1
			} else {
				// 如果 b 需要更多空间来增加树的高度
				b -= x;  // 减去已经能填满的空余节点

				// 树的高度增加，除去已填充的空余节点后，余下的 b 节点分布在 c 个叶子节点上
				cout << k + 2 + (b - 1) / c << '\n';  // 计算并输出最终高度
			}
		}
	}
	return 0;
}
/*
【问题描述】


    找出具有a+b+c个节点且高度最小的二叉树，满足以下条件：



a个节点具有2个子节点

b个节点具有1个子节点

c个节点没有子节点



    如果不存在这样的树，则输出-1， 否则输出树的高度。

5436a91f216e07df90b84e72e3d93aa9.png



  图示为a=2、b=1、c=3的满足条件的树，其高度为2。

  

  树的高度是指从根节点到最底层叶节点之间的边数之和。



【输入形式】

  输入的第一行为T，表示有T个测试样例，接下来的T行，每行3个整数a、b、c(0≤a、b、c≤105, a+b+c≥1)，分别表示所构成的树有a+b+c个节点，其中a个节点具有2个子节点，b个节点具有1个子节点，c个节点没有子节点。
【输出形式】

  输出为T行，每行一个整数，表示满足条件的树的最小高度，如果不存在这样的树，则输出-1。
【样例输入】

10
2 1 3
0 0 1
0 1 1
1 0 2
1 1 3
3 1 4
8 17 9
24 36 48
1 0 0
0 3 1
【样例输出】

2
0
1
1
-1
3
6
-1
-1
3
*/
